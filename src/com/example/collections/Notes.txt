1. Important Interfaces in collection hierarchy
a. interface Collection<E> extends Iterable<E>

--> collection can be ordered  sorted
--> ordered unsorted
--> unordered unsorted

b. interface Set<E> extends Collection :
  -> allows unique things
  class HashSet               <interface> SortedSet
  class LinkedHashSet         <interface> NavigableSet
                        class TreeSet
c.interface List<E> extends Collection<E>
   -> cares about which  position object is in (order)
   -> elements can be addeda at specified positiom
   -> if position is not specified then it will be added in end

   class ArrayList
   class Vector
   class LinkedList

d. Queue<E> extends Collection<E>
  -> Arranged in order of processing
      |
  class LinkedList ->   <interaface> dequeue
  class PriorityQueue



e. Map<K,V>
  -> key value pair
  -> with unique identifier

  class HashMap  class HashTable
  class LinkedHAshMap
  interface SortedMap -> interface NavigableMap ->class TreeMap
  is in seperate hierarchy

f. Collection<E> extends Iterable<E>
  -> boolean add(E param)
  -> boolean addAll(collection)
  -> void clear()
  -> boolean contains(Object o)
  -> boolean containsAll(Collection)
  -> boolean  equals(Object o)
  -> int hashcode()
  -> boolean isEmpty()
  -> Iterator<E> iterator
  -> boolean removeAll(Collection)
  -> boolean remove(Object param)
  -> boolean retainAll(Collection)
  -> int size
  -> Object[] toArray()
  -> <T> T() toArray(T[] a)



  Collections - Utillties -> using generics
  -> Collections - class
  -> Arrays -> binary search , copying , filling

g. equals() ->
-> method confirms that two objects are same w.r.t content
-> by default every instance gets it from object super class if we dont override
-> check equals on object content

h. hashcode() ->
it helps to identify object in heap of other object
-> returns integer
-> good if it a unique number
-> helps in improving performance of collections
-> if two objects are equal according to equals(Object) method , then calling hashcode
method on each of thw two objects must produce same integer result
-> it is not required that if two objects are unequal then calling hashcode on each two objects
must produce distinct intefer . however programmer should be aware of producing distinct intefer results for unequal objects to improve performance

g. Set
HashSet
LinkedHAshSet -> ordered based on insertion
TreeSet -> sorted so ordered based on sorting criteria
-> Set doesnot declare any extra methods other than Collection interface

h. Sort
compare one element with another element to decode which comes first
a. Comparable :
1. Java collections framework as iterface called Comparable interface
2. Comparable interface has compareTo method
int compareTo(Object o)
-> criteria is declared that is called as natural ordering for that kind of objects

object1.compareTo(object2)
>>>> if it returns -1 -> ordering is first object2 then object1
>>>> if it returns 1 -> ordering is first object 1 then object2
>>>> if it 0 -> stand at same level

3. Collections utitily class has two sort method
 static <T extends Comparable<?super T>> sort(List<T> list)
 sorts the specified list into ascending order according to natural ordering of its element

 static <T> void sort(List<T> list,Comparator<? super T> c)
 sorts the specified list according to order induced by comparator





