1. Important Interfaces in collection hierarchy
a. interface Collection<E> extends Iterable<E>

--> collection can be ordered  sorted
--> ordered unsorted
--> unordered unsorted

b. interface Set<E> extends Collection :
  -> allows unique things
  class HashSet               <interface> SortedSet
  class LinkedHashSet         <interface> NavigableSet
                        class TreeSet
c.interface List<E> extends Collection<E>
   -> cares about which  position object is in (order)
   -> elements can be addeda at specified positiom
   -> if position is not specified then it will be added in end

   class ArrayList
   class Vector
   class LinkedList

d. Queue<E> extends Collection<E>
  -> Arranged in order of processing
      |
  class LinkedList ->   <interaface> dequeue
  class PriorityQueue



e. Map<K,V>
  -> key value pair
  -> with unique identifier

  class HashMap  class HashTable
  class LinkedHAshMap
  interface SortedMap -> interface NavigableMap ->class TreeMap
  is in seperate hierarchy

f. Collection<E> extends Iterable<E>
  -> boolean add(E param)
  -> boolean addAll(collection)
  -> void clear()
  -> boolean contains(Object o)
  -> boolean containsAll(Collection)
  -> boolean  equals(Object o)
  -> int hashcode()
  -> boolean isEmpty()
  -> Iterator<E> iterator
  -> boolean removeAll(Collection)
  -> boolean remove(Object param)
  -> boolean retainAll(Collection)
  -> int size
  -> Object[] toArray()
  -> <T> T() toArray(T[] a)



  Collections - Utillties -> using generics
  -> Collections - class
  -> Arrays -> binary search , copying , filling

g. equals() ->
-> method confirms that two objects are same w.r.t content
-> by default every instance gets it from object super class if we dont override
-> check equals on object content

h. hashcode() ->
it helps to identify object in heap of other object
-> returns integer
-> good if it a unique number
-> helps in improving performance of collections
-> if two objects are equal according to equals(Object) method , then calling hashcode
method on each of thw two objects must produce same integer result
-> it is not required that if two objects are unequal then calling hashcode on each two objects
must produce distinct intefer . however programmer should be aware of producing distinct intefer results for unequal objects to improve performance

g. Set
HashSet -> unique elements , unordered , unsorted
LinkedHAshSet -> ordered based on insertion , unique elements
TreeSet -> sorted so ordered based on sorting criteria
-> Set doesnot declare any extra methods other than Collection interface

h. Sort
compare one element with another element to decode which comes first
a. Comparable :
1. Java collections framework as iterface called Comparable interface
2. Comparable interface has compareTo method
int compareTo(Object o)
-> criteria is declared that is called as natural ordering for that kind of objects

object1.compareTo(object2)
>>>> if it returns -1 -> ordering is first object2 then object1
>>>> if it returns 1 -> ordering is first object 1 then object2
>>>> if it 0 -> stand at same level

3. Collections utitily class has two sort method
 static <T extends Comparable<?super T>> sort(List<T> list)
 sorts the specified list into ascending order according to natural ordering of its element

 static <T> void sort(List<T> list,Comparator<? super T> c)
 sorts the specified list according to order induced by comparator

b. if we dont want natural ordering and we want custom sort :
Comparator interface -> of Collection framework
int compare(T o1 , T o2)
Compares arguments for order

>>>> if it returns -1 -> ordering is first object2 then object1
>>>> if it returns 1 -> ordering is first object 1 then object2
>>>> if it 0 -> stand at same level


g. TreeSet -> ordered based on sorting , unique elements
implements SortedSet , NavigableSet imterface
>>>SortedSet methods :
they are just retrieve

1. Comparator<? super E> comparator()
2. E first()
3. SortedSet<E> headSet(E element)
4. E last()
5. SortedSet<E> subSet(F fromelement , E toElement)
6. SortedSet<E> tailSet(E fromElement) -> elements grater than or equal to fromElements

there is no sort method that means when we insert elemnt they will be sorted

headSet() -> returns all elements that are on top of specified elemnt
tailSet() -> returns all elements below specified element

>>> Navigable Set :

defines utilites to fetch closest match :
1. ceiling(E e) -> returns least element in Set

2. floor(E e) -> returns greatest element in Set

3. higher(E e) -> returns least element in set strictly greater than given element

4. lower(E e) -> returns greatest element in set that is less than given element


h. for sorting if we want to use custom sorting then we can use Comparator<E>

i> Map interface > doesnot come in Collection interface
a. it needs different set of methods due to key value pair
b. No duplicates as part of key
HashMap     LinkedHashMap TreeMap
HashTable

--> hashmap doesnot have iterator directly so get keyset
keyset()/entryset has iterator()
hashmap doesnot maintain any order
it accepts null values and null keys

https://www.baeldung.com/java-hashmap

Collection views :
1. Key set view -> set of all keys of hash map
2. Value set view -> set of all values of hash map
3. View of all entries -> Map.Entry<K,V>











